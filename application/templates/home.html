{% load static %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="{% static 'css/styles.css' %}" />
	 <link rel="stylesheet" type="text/css" href="{% static 'css/bootstrap.min.css' %}" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
<link rel="stylesheet" href="{% static 'css/component.css' %}">
<link rel="stylesheet" href="{% static 'css/demo.css' %}">
<link rel="stylesheet" href="{% static 'css/normalize.css' %}">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
	<script src="{% static 'js/opencv.js' %}"></script>
  </head>

<style>


.button
{
font-weight:900;
font-size:20px;
color:black;
background:inherit;
 padding: 10px 70px;
border-color:#0ff;
border:solid:

}
.button:hover
{
box-shadow: 0px 0px 40px 10px #0ff;
background:#0ff;

}
.fig:onhover
{
box-shadow: 0px 0px 40px 10px #0ff;


}

</style>

  <body>

 <img style="display:None"  height="100" width="200" id="hiddenImage1"/>

  <canvas id="canvas" style="display:none"></canvas>




<section style="float:left;width:46%;margin-left:0%;margin-top:-30%">

    <div class = "card text-white mb-3" style="background:black;opacity:0.9;height:200px;">
	<div>
		<video  id="video" autoplay="autoplay"  src="" width="700" height="200" style="margin-top:0%;padding:0px;"  ></video>

	
	</div>
	<div>
	<div style="width:30%;margin-left:0%;float:left;">
		<button type="button" class="button" id="buttonstart" value="Start" onclick="start()">START</button>
	</div>
	<div style="width:30%;margin-left:35%;">
		<button type="button" class="button" id="buttonstop" value="Stop" onclick="stop()">STOP</button>
	</div>
<div style="width:30%;float:right;margin-top:-6.0%">
		<button type="button" class="button" id="buttonclick" value="Click" onclick="buttonclick()">CLICK</button>
	
	

	</div>
</div>

<br><br>

<div style="height:20px;">

	<input type="file" name="file-5" id="fileInput1" name="file" class="inputfile inputfile-4"  style="height:10px;float:left;display:none" />


	<label for="fileInput1" ><figure class="fig"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="10" viewBox="0 0 20 10"><path d="M10 0l-5.2 4.9h3.3v5.1h3.8v-5.1h3.3l-5.2-4.9zm9.3 11.5l-3.2-2.1h-2l3.4 2.6h-3.5c-.1 0-.2.1-.2.1l-.8 2.3h-6l-.8-2.2c-.1-.1-.1-.2-.2-.2h-3.6l3.4-2.6h-2l-3.2 2.1c-.4.3-.7 1-.6 1.5l.6 3.1c.1.5.7.9 1.2.9h16.3c.6 0 1.1-.4 1.3-.9l.6-3.1c.1-.5-.2-1.2-.7-1.5z"/></svg></figure> <span>Choose a file&hellip;</span></label>

<div style="background:black;height:70px;width:60%;margin-top:10%;color:#0ff;float:right;" id="resultdiv">


</div>		
<div style="margin-top:5%;">
<div style="opacity:0.9;width:48%;float:left;">


        <canvas id="outputcanvas" style="position:relative;" height="100" width="200"></canvas>

    </div>

 <div style="opacity:0.9;width:48%;float:right;">

        <canvas id="captured" style="position:relative;" height="100" width="200"></canvas>


        <canvas id="canvasprediction" style="position:relative;" height="100" width="200"></canvas>


    </div>
</div>


</section>

<section style="float:right;width:45%;margin-top:-20%;margin-left:5%;">

    <br>

<div id="chartContainer1" style="opacity:0.9;height: 400px; width: 600px;margin-top:10%;"></div>

   

    
</div>
   





    <img src="{% static 'files/plus2.jpg' %}" style="display:none;" height="100" width="200" id="plus"></img>



    <img src="{% static 'files/division2.jpg' %}" style="display:none;" height="100" width="200" id="division"></img>



    <img src="{% static 'files/multiplication2.jpg' %}" style="display:none;" height="100" width="200" id="multiplication"></img>





    <canvas id="mathoutput" style="display:hidden"></canvas>
    <canvas id="plusoutput" style="display:hidden"></canvas>


    <canvas id="divisionoutput" style="display:hidden"></canvas>
    <canvas id="multiplicationoutput" style="display:hidden"></canvas>














    </div>
</section>
	<script src="{% static 'js/tfjs@0.12.5.js'%}"> </script>
	<script>
  async function inittf() {
    var path = "{% static "saved/model.json" %}";
    console.log(path);
         model = await tf.loadModel(path);
        console.log("model loaded");
    }

    inittf();
</script>
    <script src="{% static 'js/three.min.js' %}"></script>
<script src="{% static 'js/canvasjs.min.js' %}"></script>
    <script src="{% static 'js/postprocessing.min.js' %}"></script>
    <script>
	
	const video = document.querySelector('video');
	var preLog = document.getElementById('preLog');
      let scene, camera, cloudParticles = [],composer;

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,1,1000);
        camera.position.z = 1;
        camera.rotation.x = 1.16;
        camera.rotation.y = -0.12;
        camera.rotation.z = 0.27;

        let ambient = new THREE.AmbientLight(0x555555);
        scene.add(ambient);

        let directionalLight = new THREE.DirectionalLight(0xff8c19);
        directionalLight.position.set(0,0,1);
        scene.add(directionalLight);

        let orangeLight = new THREE.PointLight(0xcc6600,50,450,1.7);
        orangeLight.position.set(200,300,100);
        scene.add(orangeLight);
        let redLight = new THREE.PointLight(0xd8547e,50,450,1.7);
        redLight.position.set(100,300,100);
        scene.add(redLight);
        let blueLight = new THREE.PointLight(0x3677ac,50,450,1.7);
        blueLight.position.set(300,300,200);
        scene.add(blueLight);

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth,window.innerHeight);
        scene.fog = new THREE.FogExp2(0x03544e, 0.001);
        renderer.setClearColor(scene.fog.color);
        document.body.appendChild(renderer.domElement);

        let loader = new THREE.TextureLoader();
        loader.load("{% static 'files/smoke.png' %}", function(texture){
          cloudGeo = new THREE.PlaneBufferGeometry(500,500);
          cloudMaterial = new THREE.MeshLambertMaterial({
            map:texture,
            transparent: true
          });

          for(let p=0; p<50; p++) {
            let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
            cloud.position.set(
              Math.random()*800 -400,
              500,
              Math.random()*500-500
            );
            cloud.rotation.x = 1.16;
            cloud.rotation.y = -0.12;
            cloud.rotation.z = Math.random()*2*Math.PI;
            cloud.material.opacity = 0.55;
            cloudParticles.push(cloud);
            scene.add(cloud);
          }
        });
        loader.load("{% static 'files/stars.jpg' %}", function(texture){

          const textureEffect = new POSTPROCESSING.TextureEffect({
            blendFunction: POSTPROCESSING.BlendFunction.COLOR_DODGE,
            texture: texture
          });
          textureEffect.blendMode.opacity.value = 0.2;

          const bloomEffect = new POSTPROCESSING.BloomEffect({
                blendFunction: POSTPROCESSING.BlendFunction.COLOR_DODGE,
                kernelSize: POSTPROCESSING.KernelSize.SMALL,
                useLuminanceFilter: true,
                luminanceThreshold: 0.3,
                luminanceSmoothing: 0.75
              });
          bloomEffect.blendMode.opacity.value = 1.5;

          let effectPass = new POSTPROCESSING.EffectPass(
            camera,
            bloomEffect,
            textureEffect
          );
          effectPass.renderToScreen = true;

          composer = new POSTPROCESSING.EffectComposer(renderer);
          composer.addPass(new POSTPROCESSING.RenderPass(scene, camera));
          composer.addPass(effectPass);
          
          window.addEventListener("resize", onWindowResize, false);
          render();
        });
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      function render() {
        cloudParticles.forEach(p => {
          p.rotation.z -=0.001;
        });
        composer.render(0.1);
        requestAnimationFrame(render);
      }
      init();
    </script>
	
	<script type="text/javascript">
	
        let math=new cv.MatVector();
        let mathduplicate=new cv.MatVector();


        let temp = new cv.MatVector();
        let identifiedcharacters=[];
        let poly1 = new cv.MatVector();
        let realpoly1 = [];
	
        let poly2 = new cv.MatVector();
        let poly3 = new cv.MatVector();
        let poly4 = new cv.MatVector();
        let realpoly2 = new cv.MatVector();
        let smallestindex = 0;
        //let math=cv.imread('math');
        let plus = cv.imread('plus');
        let multiplication = cv.imread('multiplication');
        let division = cv.imread('division');
        let plusduplicate = cv.imread('plus');
        let multiplicationduplicate=cv.imread('multiplication');
        let divisionduplicate=cv.imread('division');


        let contours1 = new cv.MatVector();
        let contours2 = new cv.MatVector();
        let contours3 = new cv.MatVector();
        let contours4 = new cv.MatVector();





        let hierarchy1 = new cv.Mat();
        let hierarchy2 = new cv.Mat();
        let hierarchy3 = new cv.Mat();
        let hierarchy4 = new cv.Mat();





        let out1 =new cv.Mat();
        let out2 = new cv.Mat();
        let out3 =new cv.Mat();
        let out4 =new cv.Mat();






        //let mathduplicate=cv.imread('math');










let outindexi=0;
let outindexj=0;
var topx;
var topy;
var bottomx;
var bottomy;
var indexx=[];
var indexy=[];


let graphvalues=[];

let poly = new cv.MatVector();
let inputElement1 = document.getElementById('fileInput1');
var picturetaken="nottaken";
let imgElement1 = document.getElementById('hiddenImage1');
inputElement1.addEventListener('change', (e) => {
  imgElement1.src = URL.createObjectURL(e.target.files[0]);
}, false);

imgElement1.onload = function() {


    picturetaken="nottaken";


    process();


/*
 let src=cv.imread('hiddenImage1');
let srcduplicate=cv.imread('hiddenImage1');




cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 120, 200, cv.THRESH_BINARY);
let contours = new cv.MatVector();
let hierarchy = new cv.Mat();
// You can try more different parameters
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
console.log("contours",contours.size());







for (let i = 0; i < contours.size(); ++i)
{
	
	let approx = new cv.Mat();

    
	let cnt = contours.get(i);
    
    	cv.approxPolyDP(cnt, approx, 0, true);
	//console.log(approx.size());
	//if(approx.size().height>20)
	//{
 		poly.push_back(approx);
	//}
	cnt.delete(); approx.delete();



}



console.log(poly.size());

for(let i=0;i<poly.size();i++)
{


	let mask =cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);

	


//	cv.drawContours(mask, poly, i, color, 1, cv.LINE_8, hierarchy, 0);


	//cv.drawContours(src, poly, i, color, 0, cv.LINE_8, hierarchy, 0);





    //console.log(approx.size().height); 
    //console.log("poly",poly.get(i).size().height());
let rect=cv.boundingRect(poly.get(i));
//console.log("boundiing rect",rect.x, rect.y,rect.x + rect.width, rect.y + rect.height);
if(rect.width>10)
{
let out =new cv.Mat();
//console.log("i=",i);
let color = new cv.Scalar(200,255,10);

//rect.x=rect.x-6;rect.y=rect.y-6;rect.width=rect.width+10;rect.height=rect.height+12;

let point1 = new cv.Point(rect.x, rect.y);
let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);

out=srcduplicate.roi(rect);
//console.log("out",out.cols);
cv.imshow('canvasprediction', out);








var imagedata=document.getElementById("canvasprediction");
//let img22Data=cv.imread('image1');
var tfi=imagedata.getContext("2d").getImageData(0,0,28,28);
//cv.imshow("canvas01",sub5);
//alert(sub5.data);
//show.getContext('2d').putImageData(img22Data, 0, 0);



var tfImg = tf.fromPixels(tfi, 1);
   //console.log(tfImg.shape);
   //Resize the image
  
 var smalImg = tf.image.resizeBilinear(tfImg, [28, 28]).reshape([1,28,28]);
   //alert(imageData.data);
   
   smalImg = tf.cast(smalImg, 'float32');
   var tensor = smalImg.expandDims(0);
   tensor = tensor.div(tf.scalar(255));
    
   //tensor.append(null);
    const prediction = model.predict(tensor);
    const predictedValues = prediction.dataSync();
    best = predictedValues[0];
    best_index = 0;

    

	
     for (index = 0; index < predictedValues.length; index++) {
      if ( predictedValues[index] > best) { best_index = index; best=predictedValues[index];}
      x  = Math.round(predictedValues[index]*100);
	}
    console.log(best_index);
	  graphvalues.push(best_index);	
//
















cv.rectangle(srcduplicate, point1, point2, color, 2, cv.LINE_AA, 0);
//cv.imshow("canvassingle",mask);
//cv.imshow("canvasoutput",out);

}}
//console.log("out",out.shape);

cv.imshow('outputcanvas', src);

console.log("predicted values is ",graphvalues);



cv.imshow('captured', srcduplicate);




displaychart(graphvalues);


*/







 //picturetaken1="nottaken";
  //cv.imshow('captured', out);
  //src.delete();



};



 


	function noStream()
{
	log('Access to camera was denied!');
}





function stop()
{

	var myButton = document.getElementById('buttonStop');
	if (myButton) myButton.disabled = true;
	myButton1 = document.getElementById('buttonSnap1');
	if (myButton1) myButton1.disabled = true;
	myButton1 = document.getElementById('buttonSnap2');
	if (myButton1) myButton1.disabled = true;
	if (videoStream)
	{
		if (videoStream.stop) videoStream.stop();
		else if (videoStream.msStop) videoStream.msStop();
		videoStream.onended = null;
		videoStream = null;
	}
	if (video)
	{
		video.onerror = null;
		video.pause();
		if (video.mozSrcObject)
			video.mozSrcObject = null;
		video.src = "";
	}
	myButton = document.getElementById('buttonStart');
	if (myButton) myButton.disabled = false;
	
	//document.getElementById("video").setAttribute('poster',"{% static 'files/smoke.png' %}");
	video.srcObject=null;
	//video.posterObject="{% static 'files/smoke.png' %}";
}

function gotStream(stream)
{
	var myButton = document.getElementById('buttonStart');
	if (myButton) myButton.disabled = true;
	videoStream = stream;
	//console.log('Got stream.');
	video.onerror = function ()
	{
		//console.log('video.onerror');
		if (video) stop();
	};
	stream.onended = noStream;
	//if (window.webkitURL) video.src = window.webkitURL.createObjectURL(stream);
	 if (video.mozSrcObject !== undefined)
	{//FF18a
		video.mozSrcObject = stream;
		video.play();
	}
	else if (navigator.mozGetUserMedia)
	{//FF16a, 17a
		video.src = stream;
		video.play();
	}
	//else if (window.URL) video.src = window.URL.createObjectURL(stream);
	else video.src = stream;
	myButton = document.getElementById('buttonSnap');
	if (myButton) myButton.disabled = false;
	myButton = document.getElementById('buttonStop');
	if (myButton) myButton.disabled = false;
	
	
	
	
}



function buttonclick()
{
    picturetaken="taken";
   
//console.log("click");

var  canvas=document.getElementById('canvas');

canvas.height=video.videoHeight;
canvas.width=video.videoWidth;
canvas.getContext('2d').drawImage(video, 0, 0);


var canvas=cv.imread("canvas");

for (let i = 0; i < canvas.rows; i++) {
    for (let j = 0; j < canvas.cols; j++) {
	if(canvas.ucharPtr(i,j)[0]>100) canvas.ucharPtr(i, j)[0] = 0;
	else canvas.ucharPtr(i, j)[0] = 255;
    if(canvas.ucharPtr(i,j)[1]>100)canvas.ucharPtr(i, j)[1] = 0;   
	else canvas.ucharPtr(i, j)[1] = 255;
		 if(canvas.ucharPtr(i,j)[2]>100)canvas.ucharPtr(i, j)[2] = 0;   
	else canvas.ucharPtr(i, j)[2] = 255;

}}

let dsize=new cv.Size(200,100);
cv.resize(canvas,canvas,dsize,0,0,cv.INTER_AREA);
cv.imshow("canvas",canvas);
//cv.imshow("captured",canvas);
    
    process();




    /*

let src=cv.imread("canvas");
let srcduplicate=cv.imread('canvas');
let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
let dsize=new cv.Size(200,200);
cv.resize(src,src,dsize,0,0,cv.INTER_AREA);
cv.imshow("outputcanvas",src);


var white=0;
var black=0;
for (let i = 0; i < src.rows; i++) {
    for (let j = 0; j < src.cols; j++) {
	if(src.ucharPtr(i,j)[0]>50) white=white+1;
	else black=black+1;
    if(src.ucharPtr(i,j)[1]>50)white=white+1;
	else black=black+1;
		 if(src.ucharPtr(i,j)[2]>50)white=white+1;
	else black=black+1;
	
   }
}


console.log("white = ",white);
console.log("black = ",black);





cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
//cv.threshold(src, src, 120, 200, cv.THRESH_BINARY);
let contours = new cv.MatVector();
let hierarchy = new cv.Mat();
// You can try more different parameters
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
console.log("contours",contours.size());









cv.imshow("captured",src)




var graphvalues=[1,4,0];
displaychart(graphvalues);


// video.srcObject=src;


    //predict1();
    

    */
}



function start()
{
console.log("start");
const constraints = {
  video: true
};





navigator.mediaDevices.getUserMedia(constraints).
  then((stream) => {video.srcObject = stream;console.log(typeof stream);});
myButton1 = document.getElementById('buttonSnap1');
	if (myButton1) myButton1.disabled = false;
	myButton1 = document.getElementById('buttonSnap2');
	if (myButton1) myButton1.disabled = false;
	if ((typeof window === 'undefined') || (typeof navigator === 'undefined')) console.log('This page needs a Web browser with the objects window.* and navigator.*!');
	else if (!(video )) console.log('HTML context error!');
	else
	{
	
		
		if (navigator.getUserMedia) navigator.getUserMedia({video:true}, gotStream, noStream);
		else if (navigator.oGetUserMedia) navigator.oGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.mozGetUserMedia) navigator.mozGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.webkitGetUserMedia) navigator.webkitGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.msGetUserMedia) navigator.msGetUserMedia({video:true, audio:false}, gotStream, noStream);
		//else log('getUserMedia() not available from your Web browser!');
	}
}







function displaychart(graphvalues)
{





var predictedValues=[];

var dps=[];



var chart = new CanvasJS.Chart("chartContainer1", {
	animationEnabled: true,
	theme: "dark1", // "light1", "light2", "dark1", "dark2"
	title: {
		text: "PREDICTED DIGITS"
	},
	axisY: {
		title: " predicted percentage for digits",
		suffix: "%",
		includeZero: false
	},
	axisX: {
		title: "digits"
	},
	data: [{
		type: "column",
		yValueFormatString: "#,##0.0#\"%\"",
		dataPoints:dps
	}]
});
	
	
	
	var xVal = 0;
var yVal = 0; 
	
let dpsdata;	

	
     for (index = 0; index <10; index++) {


	//console.log("index of ",index , " is  " ,graphvalues.indexOf(index));
     if(graphvalues.indexOf(index)>=0)
  {
		
		dps.push({
			x: index,
			y: 100
		});
		
}	
else
{

dps.push({
			x: index,
			y: 0
		});
}

	 
	 
	
           
    }   
	chart.render();







}




function process()
{

    
    //let math=cv.imread("canvas");
    //let mathduplicate=cv.imread('canvas');
    
   if(picturetaken=="nottaken")
   {
        //console.log("picture not taken");
         math=cv.imread("hiddenImage1");
         mathduplicate=cv.imread('hiddenImage1');
  }
  else
 {
  math=cv.imread("canvas");
  mathduplicate=cv.imread('canvas');

   }


   

    cv.cvtColor(math, math, cv.COLOR_RGBA2GRAY, 0);
    cv.cvtColor(plus,plus, cv.COLOR_RGBA2GRAY, 0);
    cv.cvtColor(multiplication,multiplication, cv.COLOR_RGBA2GRAY, 0);
    cv.cvtColor(division, division, cv.COLOR_RGBA2GRAY, 0);



    cv.threshold(math, math, 120, 200, cv.THRESH_BINARY);
    cv.threshold(plus, plus, 120, 200, cv.THRESH_BINARY);
    cv.threshold(multiplication, multiplication, 120, 200, cv.THRESH_BINARY);
    cv.threshold(division,division, 120, 200, cv.THRESH_BINARY);



        

    cv.findContours(math, contours1, hierarchy1, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
    cv.findContours(plus, contours2, hierarchy2, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
    cv.findContours(multiplication, contours3, hierarchy3, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
    cv.findContours(division, contours4, hierarchy4, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);



        
   // console.log("contours 1 sizea ", contours1.size());
    //console.log("plus sizea ", contours2.size());
    //console.log("multiplication sizea ", contours3.size());
   // console.log("division sizea ", contours4.size());







    
    for (let i = 0; i < contours1.size(); ++i)
    {
        //  console.log("contours", contours1.get(i));
        let approx = new cv.Mat();

    
        let cnt = contours1.get(i);
    
        cv.approxPolyDP(cnt, approx, 0, true);
        //console.log(approx.size());
        //if(approx.size().height>20)
        //{
        poly1.push_back(approx);
        //}
        cnt.delete(); approx.delete();



    }






    for (let i = 0; i < contours2.size(); ++i)
    {
	
        let approx = new cv.Mat();

    
        let cnt = contours2.get(i);
        
        cv.approxPolyDP(cnt, approx, 0, true);
        //console.log(approx.size());
        //if(approx.size().height>20)
        //{
        poly2.push_back(approx);
        //}
        cnt.delete(); approx.delete();
    }






    for (let i = 0; i < contours3.size() ; ++i) {

        let approx = new cv.Mat();


        let cnt = contours3.get(i);

        cv.approxPolyDP(cnt, approx, 0, true);
        //console.log(approx.size());
        //if(approx.size().height>20)
        //{
        poly3.push_back(approx);
        //}
        cnt.delete(); approx.delete();
    }







    for (let i = 0; i < contours4.size() ; ++i) {

        let approx = new cv.Mat();


        let cnt = contours4.get(i);

        cv.approxPolyDP(cnt, approx, 0, true);
        //console.log(approx.size());
        //if(approx.size().height>20)
        //{
        poly4.push_back(approx);
        //}
        cnt.delete(); approx.delete();
    }



    //unsortedpoly1.sort();






    
    for (let i = 0; i < poly2.size() ; i++) {


        let mask = cv.Mat.zeros(plus.rows, plus.cols, cv.CV_8UC3);




        //	cv.drawContours(mask, poly, i, color, 1, cv.LINE_8, hierarchy, 0);


        //cv.drawContours(src, poly, i, color, 0, cv.LINE_8, hierarchy, 0);





        //console.log(approx.size().height); 
        //console.log("poly",poly.get(i).size().height());
        let rect = cv.boundingRect(poly2.get(i));
        //console.log("boundiing rect",rect.x, rect.y,rect.x + rect.width, rect.y + rect.height);

        //let out =new cv.Mat();
        //console.log("i=",i);
        let color = new cv.Scalar(200, 255, 10);

        //rect.x=rect.x-6;rect.y=rect.y-6;rect.width=rect.width+10;rect.height=rect.height+12;

        let point1 = new cv.Point(rect.x, rect.y);
        let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);

        //console.log("plus=",rect.width,rect.height);
        cv.rectangle(plusduplicate, point1, point2, color, 2, cv.LINE_AA, 0);


        out2 = plusduplicate.roi(rect);
        let dsize = new cv.Size(70, 100);
        cv.resize(out2, out2, dsize, 0, 0, cv.INTER_AREA);

        //cv.cvtColor(out2, out2, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(out2, out2, 120, 255, cv.THRESH_BINARY);
       // console.log("out", out2.cols);
        cv.imshow("plusoutput", out2)


    }











    for (let i = 0; i < poly3.size() ; i++) {


        let mask = cv.Mat.zeros(multiplication.rows, multiplication.cols, cv.CV_8UC3);




        //	cv.drawContours(mask, poly, i, color, 1, cv.LINE_8, hierarchy, 0);


        //cv.drawContours(src, poly, i, color, 0, cv.LINE_8, hierarchy, 0);





        //console.log(approx.size().height); 
        //console.log("poly",poly.get(i).size().height());
        let rect = cv.boundingRect(poly3.get(i));
        //console.log("boundiing rect",rect.x, rect.y,rect.x + rect.width, rect.y + rect.height);

        //let out =new cv.Mat();
        //console.log("i=",i);
        let color = new cv.Scalar(200, 255, 10);

        //rect.x=rect.x-6;rect.y=rect.y-6;rect.width=rect.width+10;rect.height=rect.height+12;

        let point1 = new cv.Point(rect.x, rect.y);
        let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);

        //console.log("plus=",rect.width,rect.height);
        cv.rectangle(multiplicationduplicate, point1, point2, color, 2, cv.LINE_AA, 0);


        out3 = multiplicationduplicate.roi(rect);
        let dsize = new cv.Size(70, 100);
        cv.resize(out3, out3, dsize, 0, 0, cv.INTER_AREA);

        //cv.cvtColor(out2, out2, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(out3, out3, 120, 255, cv.THRESH_BINARY);
        //console.log("out", out3.cols);
        cv.imshow("multiplicationoutput", out3)


    }










    for (let i = 0; i < poly4.size() ; i++) {


        let mask = cv.Mat.zeros(division.rows, division.cols, cv.CV_8UC3);




        //	cv.drawContours(mask, poly, i, color, 1, cv.LINE_8, hierarchy, 0);


        //cv.drawContours(src, poly, i, color, 0, cv.LINE_8, hierarchy, 0);





        //console.log(approx.size().height); 
        //console.log("poly",poly.get(i).size().height());
        let rect = cv.boundingRect(poly4.get(i));
        //console.log("boundiing rect",rect.x, rect.y,rect.x + rect.width, rect.y + rect.height);

        //let out =new cv.Mat();
        //console.log("i=",i);
        let color = new cv.Scalar(200, 255, 10);

        //rect.x=rect.x-6;rect.y=rect.y-6;rect.width=rect.width+10;rect.height=rect.height+12;

        let point1 = new cv.Point(rect.x, rect.y);
        let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);

        //console.log("plus=",rect.width,rect.height);
        cv.rectangle(divisionduplicate, point1, point2, color, 2, cv.LINE_AA, 0);


        out4 = divisionduplicate.roi(rect);
        let dsize = new cv.Size(70, 100);
        cv.resize(out4, out4, dsize, 0, 0, cv.INTER_AREA);

        //cv.cvtColor(out2, out2, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(out4, out4, 120, 255, cv.THRESH_BINARY);
       // console.log("out", out4.cols);
        cv.imshow("divisionoutput", out4)


    
    }







   // cv.imshow('canvasprediction', mathduplicate);









    

    let plusdemochar = cv.imread("plusoutput");
    let multiplicationdemochar = cv.imread("multiplicationoutput");
    let divisiondemochar = cv.imread("divisionoutput");


    cv.cvtColor(plusdemochar, plusdemochar, cv.COLOR_RGBA2GRAY, 0);
    cv.cvtColor(multiplicationdemochar, multiplicationdemochar, cv.COLOR_RGBA2GRAY, 0);
    cv.cvtColor(divisiondemochar, divisiondemochar, cv.COLOR_RGBA2GRAY, 0);


    
    let pluscontourscompare = new cv.MatVector();
    let plushierarchycompare = new cv.Mat();
    let multiplicationcontourscompare = new cv.MatVector();
    let multiplicationhierarchycompare = new cv.Mat();
    let divisioncontourscompare = new cv.MatVector();
    let divisionhierarchycompare = new cv.Mat();



    cv.findContours(plusdemochar, pluscontourscompare, plushierarchycompare, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

    //console.log("plus char contours size ",pluscontourscompare.size());


    cv.findContours(multiplicationdemochar, multiplicationcontourscompare,multiplicationhierarchycompare, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

    //console.log("multiplication char contours size ", multiplicationcontourscompare.size());


    cv.findContours(divisiondemochar, divisioncontourscompare, divisionhierarchycompare, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

    //console.log("division char contours size ", divisioncontourscompare.size());


    //console.log("symbol contours suze char ", contourssymbol1.size());

    let plushull = new cv.Mat();
    let plusdefect = new cv.Mat();
    
    let multiplicationhull = new cv.Mat();
    let multiplicationdefect = new cv.Mat();

    let divisionhull = new cv.Mat();
    let divisiondefect = new cv.Mat();


    
    cv.convexHull(pluscontourscompare.get(0), plushull, false, false);
    cv.convexityDefects(pluscontourscompare.get(0), plushull, plusdefect);


    //console.log("plus defects ", plusdefect.rows);



    cv.convexHull(multiplicationcontourscompare.get(0), multiplicationhull, false, false);
    cv.convexityDefects(multiplicationcontourscompare.get(0), multiplicationhull, multiplicationdefect);


    //console.log("multiplication defects ", multiplicationdefect.rows);





    cv.convexHull(divisioncontourscompare.get(0), divisionhull, false, false);
    cv.convexityDefects(divisioncontourscompare.get(0), divisionhull, divisiondefect);


    //console.log("division defects ", divisiondefect.rows);





    

    
    let plusstart = new cv.Point(pluscontourscompare.get(0).data32S[plusdefect.data32S[0 * 4] * 2],
                         pluscontourscompare.get(0).data32S[plusdefect.data32S[0 * 4] * 2 + 1]);

    
    let multiplicationstart = new cv.Point(multiplicationcontourscompare.get(0).data32S[multiplicationdefect.data32S[0 * 4] * 2],
                         multiplicationcontourscompare.get(0).data32S[multiplicationdefect.data32S[0 * 4] * 2 + 1]);

    
    let divisionstart = new cv.Point(divisioncontourscompare.get(0).data32S[divisiondefect.data32S[0 * 4] * 2],
                         divisioncontourscompare.get(0).data32S[divisiondefect.data32S[0 * 4] * 2 + 1]);







    


    for(let i=0;i<poly1.size();i++)
    {


        let mask =cv.Mat.zeros(math.rows, math.cols, cv.CV_8UC3);

	


        //	cv.drawContours(mask, poly, i, color, 1, cv.LINE_8, hierarchy, 0);


        //cv.drawContours(src, poly, i, color, 0, cv.LINE_8, hierarchy, 0);





        //console.log(approx.size().height); 
        //console.log("poly",poly.get(i).size().height());
        let rect=cv.boundingRect(poly1.get(i));
        //console.log("boundiing rect",rect.x, rect.y,rect.x + rect.width, rect.y + rect.height);

        //let out =new cv.Mat();

        let color = new cv.Scalar(255,0,0);

        //rect.x=rect.x-6;rect.y=rect.y-6;rect.width=rect.width+10;rect.height=rect.height+12;
        console.log("rect width",rect.width,rect.height);

        if(rect.width>10)

        {
            //realpoly1.push_back(poly1.get(i));



            let point1 = new cv.Point(rect.x, rect.y);
            let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);


            cv.rectangle(mathduplicate, point1, point2, color, 2, cv.LINE_AA, 0);
            //console.log("i=",i);
            //console.log("get",poly1.get(i).data);
            out1=mathduplicate.roi(rect);
            //console.log("out",out.cols);
                        //console.log("realpoly pushed");
            //if(i==3)
            //{
    
            //console.log("minus = ",contours1.get(i));
            //console.log("minus = ",rect.width,rect.height);
            //let Moments = cv.moments(contours1.get(i), false);
            //console.log("moments = ",Moments);
            //console.log("extent = ",extent);
            let dsize=new cv.Size(70,100);
            cv.resize(out1,out1,dsize,0,0,cv.INTER_AREA);
            for(let r=0;r<out1.rows;r++)
            {
                for(let c=0;c<out1.cols;c++)
                {
                    if(out1.ucharPtr(r,c)[0]>250) out1.ucharPtr(r, c)[0] = 255;
                    else out1.ucharPtr(r, c)[0] = 0;
                    if(out1.ucharPtr(r,c)[1]>100)out1.ucharPtr(r, c)[1] = 255;   
                    else out1.ucharPtr(r, c)[1] = 0;
                    if(out1.ucharPtr(r,c)[2]>100)out1.ucharPtr(r, c)[2] = 255;   
                    else out1.ucharPtr(r, c)[2] = 0;

                }
            }



            let area = cv.contourArea(contours1.get(i), false);
            let rectarea = cv.boundingRect(poly1.get(i));
            let rectArea = rectarea.width * rectarea.height;
            let extent = area / (rect.width * rect.height);
            //console.log("extent",extent , "height",rect.height);
            if (extent > 0.60 && rect.height<30) {
                
let white=0;
let black=0;
for(let r=0;r<out1.rows;r++)
            {
                for(let c=0;c<out1.cols;c++)
                {
                    if(out1.ucharPtr(r,c)[0]>250) white++;
                    else black++;
                    if(out1.ucharPtr(r,c)[1]>100)white++;   
                    else black++;
                    if(out1.ucharPtr(r,c)[2]>100)white++;   
                    else black++;

                }
            }
if(white<black)continue;
else
{
                console.log("pushed minus");realpoly1.push(poly1.get(i).data[0]);

                identifiedcharacters.push("-");
                continue;
            }
}

if(rect.height<20)continue;


            //cv.cvtColor(out1, out1, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(out1, out1, 120, 255, cv.THRESH_BINARY);
           
            cv.imshow("mathoutput", out1);


            let demochar = cv.imread("mathoutput");
            cv.cvtColor(demochar, demochar, cv.COLOR_RGBA2GRAY, 0);



            let contourssymbol1 = new cv.MatVector();
            let hierarchysymbol1 = new cv.Mat();


            // You can try more different parameters
            cv.findContours(demochar, contourssymbol1, hierarchysymbol1, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

          //  console.log("demo char ", contourssymbol1.size());

            //console.log("after ",conto);


            let characterhull = new cv.Mat();
            let characterdefect = new cv.Mat();


            cv.convexHull(contourssymbol1.get(0), characterhull, false, false);
            cv.convexityDefects(contourssymbol1.get(0), characterhull, characterdefect);
            //console.log("character defects  ",characterdefect.rows," i ",i );





            let characterstart = new cv.Point(contourssymbol1.get(0).data32S[characterdefect.data32S[0 * 4] * 2],
                                 contourssymbol1.get(0).data32S[characterdefect.data32S[0 * 4] * 2 + 1]);





            //console.log("character start", characterstart.y);



            let resultplus = cv.matchShapes(contourssymbol1.get(0), pluscontourscompare.get(0), 1, 0);
            //console.log("compare with plus ", result, " i ", i);
            //console.log("charcater start",characterstart.y," plus start  ",plusstart.y);
            if (resultplus < 3.0 && characterdefect.rows == plusdefect.rows && ((characterstart.y - plusstart.y) < 10 && (characterstart.y -plusstart.y) > -10))
            {
               console.log("pushed plus ");realpoly1.push(poly1.get(i).data[0]);

                identifiedcharacters.push("+");
                continue;

            }

            let resultmultiplication = cv.matchShapes(contourssymbol1.get(0), multiplicationcontourscompare.get(0), 1, 0);
		
            if (resultmultiplication < 5.0 && characterdefect.rows == multiplicationdefect.rows && ((characterstart.y - multiplicationstart.y) < 10 && (characterstart.y -multiplicationstart.y) > -10))
            {
                console.log("pushed multiplication ");realpoly1.push(poly1.get(i).data[0]);

                identifiedcharacters.push("*");
                continue;
            }



    
            let resultdivision = cv.matchShapes(contourssymbol1.get(0), divisioncontourscompare.get(0), 1, 0);
console.log("division comparision",resultdivision,characterdefect.rows,divisiondefect.rows);
            if (resultdivision < 5.0 && ((characterstart.y - divisionstart.y) < 20 && (characterstart.y -divisionstart.y) > -20) && characterdefect.rows == divisiondefect.rows  )
            {
                console.log("pushed division ");realpoly1.push(poly1.get(i).data[0]);

                identifiedcharacters.push("/");
                continue;
            }

            else
            {
                dsize=new cv.Size(28,28);
                cv.resize(out1,out1,dsize,0,0,cv.INTER_AREA);
                cv.imshow("mathoutput",out1);
                console.log("identified number ");
           let numberidentified=  predictcharacters();
		console.log("pushed ",numberidentified);realpoly1.push(poly1.get(i).data[0]);

           identifiedcharacters.push(numberidentified);
                continue;
            }
        }
    }
    cv.imshow('captured', mathduplicate);
    cv.imshow('outputcanvas', math);


    displaychart(graphvalues);


    
    let temp1;
    for (let i = 0; i < realpoly1.length; i++)
    {
        for(let j=i;j<realpoly1.length;j++)
        {
            if(realpoly1[i]>realpoly1[j])
            {
                temp1 = realpoly1[i];
                realpoly1[i] = realpoly1[j]
                realpoly1[j] = temp1;


                temp1 = identifiedcharacters[i];
                identifiedcharacters[i] = identifiedcharacters[j];
                identifiedcharacters[j]=temp1;
            }

        }

    }




    let characterarray=["+","-","/","*"];
    let finalanswer="";

    let stackresult=[];
    console.log("length of identified" ,identifiedcharacters.length);
    console.log("real poly");
   // for (let i = 0; i < realpoly1.length ; i++)
    //    console.log("real poly ",realpoly1[i]);

    //console.log("real characters");
    let finalresult=0;
    let flag=1;
    for (let i = 0; i <identifiedcharacters.length ; i++)
    {
        console.log("real charatcers ", identifiedcharacters[i]);
        finalanswer=finalanswer+""+identifiedcharacters[i];
        if(i==0)
        {

            // first character should not be operator
            if(characterarray.indexOf(identifiedcharacters[i])!=-1)
            {
                flag=0;

             //   finalresult=" invalid expression ";break;

            }

            
        }
        if(i==identifiedcharacters.length-1)
        {

            // last character should not be operator

            if(characterarray.indexOf(identifiedcharacters[i])!=-1)
            {
                flag=0;
             //   finalresult="invlaid expression";break;
            }


            //if last character is number
            //if previous character is operatator than push as it is
            if(characterarray.indexOf(identifiedcharacters[i-1])!=-1 && characterarray.indexOf(identifiedcharacters[i])==-1)
            {
                finalresult=parseInt(identifiedcharacters[i]);
                stackresult.push(finalresult);
            }
            else
            {
                finalresult=finalresult*10+parseInt(identifiedcharacters[i]);
                stackresult.push(finalresult);

            }


        }
        if(characterarray.indexOf(identifiedcharacters[i])!=-1 && i!=identifiedcharacters.length-1)
        {
            // if current character is operator then next character should not be operator
            if(characterarray.indexOf(identifiedcharacters[i+1])!=-1)
            {
               // finalresult="invlaid expression";break;
            
                flag=0;
            }
            


        }

        if(characterarray.indexOf(identifiedcharacters[i])==-1 && i!=0  && characterarray.indexOf(identifiedcharacters[i-1])==-1)
        {
            //if there are 2 consecutive numbers
		
            finalresult=finalresult*10+parseInt(identifiedcharacters[i]);

        }
       else if(identifiedcharacters[i]=='+')
        {
            console.log("plus");
          //  finalresult=finalresult+parseIntidentifiedcharacters[i+1];
            stackresult.push(finalresult);
            stackresult.push("+");
            finalresult=0;

        }
        else if(identifiedcharacters[i]=='-')
        {
           // finalresult-=identifiedcharacters[i+1];
            stackresult.push(finalresult);
            finalresult=0;
            stackresult.push("-");
        
        
        }


        else if(identifiedcharacters[i]=='*')
        {
            // finalresult*=identifiedcharacters[i+1];
            stackresult.push(finalresult);
            stackresult.push("*");
            finalresult=0;
        }

        else if(identifiedcharacters[i]=='/')
        {
            //finalresult/=identifiedcharacters[i+1];
            stackresult.push(finalresult);
            stackresult.push("/");
            finalresult=0;
        }

        else
        {
            console.log("one");
            finalresult=parseInt(identifiedcharacters[i]);
            //stackresult.push(identifiedcharacters[i])
        }
    }
   
    console.log("stack");
    for(let i=0;i<stackresult.length;i++)
    {
        console.log(stackresult[i]);

    }



    
    if(flag==0)
    {
        finalresult="invalid expression";
        let resultdiv=document.getElementById("resultdiv");
        resultdiv.innerHTML="<br><center>"+finalanswer+" = invalid expression</center><br>";
        
       // alert(finalanswer+ " =  invalid expression");

    }

    else
    {




        
        finalresult=0;

        let flag1=0;
        //flag 1 is used to check if there is minimum of one operator in our stack
        // if no operator are present then the first element of the stack is the final answer
        while(1)
        {
            console.log("loop ",stackresult.length);
            if(stackresult.length<=1)break;

            for(i=0;i<stackresult.length;i++)
            {
                if(stackresult[i]=="/")
                {
                    flag1=1;
                    console.log("stack result /",finalresult);

                    finalresult=(stackresult[i-1]/stackresult[i+1]);
                    stackresult[i-1]=finalresult;
                    stackresult.splice(i,2);i--;

                }

            }
            for(i=0;i<stackresult.length;i++)
            {
                if(stackresult[i]=="*")
                {
                    flag1=1;
                    //console.log("stack result *",finalresult);

                    finalresult=(stackresult[i-1]*stackresult[i+1]);
                    stackresult[i-1]=finalresult;
                    stackresult.splice(i,2);i--;
                }

            }






            for(i=0;i<stackresult.length;i++)
            {
                if(stackresult[i]=="+")
                {
                    flag1=1;

                    if(i-1!=0)
                    {
                        if(stackresult[i-2]=="+")
                        stackresult[i-1]=stackresult[i-1]*1;
                        else
                            stackresult[i-1]=stackresult[i-1]*(-1);
                    }

                    finalresult=(stackresult[i-1]+stackresult[i+1]);
                    stackresult[i-1]=finalresult;
                    stackresult.splice(i,2);
                    console.log("stack result  ",i," + ",stackresult[i-1]);
			i--;

                }

	}     
        

            
            
            
            for(i=0;i<stackresult.length;i++)
            {
                if(stackresult[i]=="-")
                {
                    flag1=1;

			let temp1=0;let temp2=0;
			let symbol="minus";
			
                    if(stackresult[i+1]<0)
			{
			console.log("minus ",stackresult[i-1],stackresult[i+1]);
			stackresult[i+1]=stackresult[i+1]*(-1);
			console.log(stackresult[i+1]);
			if(stackresult[i+1]>stackresult[i-1])symbol="minus";
			else symbol="plus";
			finalresult=(stackresult[i-1]-stackresult[i+1]);
	
			console.log("symbol ",symbol);
			if(symbol=="minus")
			{
				finalresult=finalresult*(1);
				//console.log("inside symbol",finalresult);
			}
			else
			{
				finalresult=finalresult*(-1);
				//console.log("inside symbol",finalresult);
			}

			stackresult[i-1]=finalresult;
			console.log("final result - ",finalresult);
			}
			
			else
			{
			finalresult=(stackresult[i-1]-stackresult[i+1]);
			stackresult[i-1]=finalresult;

			}
                    
			//console.log("finalersult",finalresult,parseInt(stackresult[i-1]),parseInt(stackresult[i+1]));	
                    
                 // let value1=6;
		 // let value2=-238;
                 //  let value3=value1-value2;
			//console.log("value3 =" ,value3);

                    stackresult.splice(i,2);
                    //console.log("stack result ",i," - ",stackresult[i-1]);
			i--;
                }
                // console.log();
               
            }



          
        
            if(flag1==0)
            {
                finalresult=stackresult[0];
                break;
            }


        }










	if(stackresult.length==1)
	{
		finalresult=stackresult[0];
	}



        finalanswer=finalanswer+"="+finalresult;
      //  alert(finalanswer);
        let resultdiv=document.getElementById("resultdiv");
        resultdiv.innerHTML="<br><center><font size='5'>"+finalanswer+"</font></center><br>";

    }
    //alert(finalanswer);

    














}




	
function predictcharacters()
{



    

    var imagedata=document.getElementById("mathoutput");
    //let img22Data=cv.imread('image1');
    var tfi=imagedata.getContext("2d").getImageData(0,0,28,28);
    //cv.imshow("canvas01",sub5);
    //alert(sub5.data);
    //show.getContext('2d').putImageData(img22Data, 0, 0);



    var tfImg = tf.fromPixels(tfi, 1);
    //console.log(tfImg.shape);
    //Resize the image
  
    var smalImg = tf.image.resizeBilinear(tfImg, [28, 28]).reshape([1,28,28]);
    //alert(imageData.data);
   
    smalImg = tf.cast(smalImg, 'float32');
    var tensor = smalImg.expandDims(0);
    tensor = tensor.div(tf.scalar(255));
    
    //tensor.append(null);
    const prediction = model.predict(tensor);
    const predictedValues = prediction.dataSync();
    best = predictedValues[0];
    best_index = 0;

    

	
    for (index = 0; index < predictedValues.length; index++) {
        if ( predictedValues[index] > best) { best_index = index; best=predictedValues[index];}
        x  = Math.round(predictedValues[index]*100);
    }
    
    console.log("best index is ",best_index,predictedValues);
    graphvalues.push(best_index);	
    return best_index;

}
	
	</script>
	
	
	<script src="{% static 'js/custom-file-input.js' %}"></script>

		<!-- // If you'd like to use jQuery, check out js/jquery.custom-file-input.js
		<script src="{% static 'js/jquery-v1.min.js' %}"></script>
		<script src="{% static 'js/jquery.custom-file-input.js' %}"></script>
  </body>
</html>
